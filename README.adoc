:toc: left
:toclevels: 3

= Session-based Authentication in Rust

[[sec-intro]]
== Introduction 

Session-based authentication provides a secure and efficient alternative to Basic authentication schemes.
Unlike Basic authentication, where credentials are sent with every request, session-based authentication validates user credentials once and then uses session tokens for subsequent  requests.

[[sec-advantages]]
== Key Advantages

* *Reduced network exposure*: Credentials (username and password) are transmitted only during the initial login, minimizing the risk of interception
* *Improved performance*: Server validates credentials once during login; subsequent requests only require session ID validation
* *Enhanced security*: Session IDs stored in cookies replace repeated credential transmission
* *Stateful management*: Server maintains session state and securely hashed credentials, enabling easier session invalidation and logout
* *Extra flexibility*: Sessions can store additional metadata (e.g., roles, permissions, expiration time, etc), allowing:
role-based access control, permission management, configurable session expiration, prevention of session hijacking and other security threats.

[[sec-flows]]
== Authentication flows

The flow of session-based authentication process can be described according its distinct phases:

[[sec-signup]]
=== User Registration (Sign-up) 

. User submits username + password (over HTTPS only).
. Server generates a random salt (e.g. 16–32 bytes).
. Server hashes the password with a password hashing algorithm (bcrypt, Argon2, or scrypt), e.g., `hashed_password = bcrypt(password + salt)`
. Server stores in DB: username,  hashed_password, salt (not secret, stored alongside the hash) and optional metadata (e.g. password version, created_at).

NOTE: Storing only hashes prevents leaks from exposing real passwords.
 
[[sec-login]]
=== User Login (Sign-in) 

. User submits username + password (over HTTPS).
. Server looks up the stored record for that username.
. Server retrieves salt and hashed_password.
. Server recomputes bcrypt(submitted_password + salt).
. If `computed hash == stored hash` → authentication succeeds.

NOTE: Password is never stored or logged, only verified securely.

[[sec-session-creation]]
=== Session Creation

If successful authentication: 

. Server generates a session ID (random, cryptographically strong).
. Server stores session info in memory or DB (Redis, SQL, etc.).
. Server sends the session ID back to the client in a cookie with `Set-Cookie`, remember these options:
.. *HttpOnly*:  The cookie cannot be accessed by JavaScript, protects against XSS (Cross-Site Scripting) attacks.
.. *Secure*: The cookie is only sent over HTTPS, never over plain HTTP, prevents session hijacking via network sniffing.
.. *SameSite*=Strict or *SameSite*=Lax: Controls when cookies are sent in cross-site requests, prevents CSRF (Cross-Site Request Forgery) attacks. 

.example 1: A session stored in memory or DB on the server could look like this
[example]
----
{
  "session_id": "abc123xyz",
  "user_id": "42",
  "expires_at": "2025-09-24T12:00:00Z",
  "ip": "optional",
  "user_agent": "optional"
}
----


.example 2: A Server's response to a login request, providing session information
[example]
----
HTTP/1.1 200 OK
Set-Cookie: session_id=abc123xyz; HttpOnly; Secure;SameSite=Lax; Path=/; Max-Age=1800
Content-Type: application/json
----


[[sec-subsequent-requests]]
===  Subsequent Requests

. Client includes the session cookie automatically.
. Server (middleware) looks up the session ID in the sessionn store (memory or DB), verifies its validity,  attaches user identity to the request (e.g., this request comes from username: "alice", id: 42) before forwarding it to the request handler. 


.example 3: One client's subsequent request should look like this
[example]
----
GET /dashboard HTTP/1.1
Host: example.com
Cookie: session_id=abc123xyz
----

.example 4: Session middleware finds out session information from the Session Store
[example]
----
{
  "session_id": "abc123xyz",
  "user_id": 42,
  "username": "alice",
  "roles": ["admin"],
  "expires_at": "2025-09-24T12:00:00Z"
}
----

NOTE: Passwordd never need to be re-sent, it only proves identity using the session ID.

[[sec-expiration]]
=== Session Expiration and Renewal

. Sessions should expire after a reasonable time (e.g. 15-30 min inactivity, max 1-7 days).
. On logout
.. Server deletes session from server's Session Store.
.. Server clears client's cookie:  server responds with `Set-Cookie: session_id=; Max-Age=0`
. Any future request without a valid cookie is treated as user is `logged out`.


[[sec-actix-middlewares]]
== Session-based Authentication with Rust and Actix Web Middlewares

The `actix-session` is a complete toolkit for handling user sessions in your Actix Web application. It's designed to make session management simple and flexible.
The `SessionMiddleware` is the middleware providing the `actix-session` functionalities. 

It takes care of all the session cookie handling and instructs the storage backend to create/delete/update the session state based on the operations performed against the active session. Sessions are backed by a `SessionStore`. 

The `SessionStore` is the interface used to retrieve and save the current session data from/to the chosen storage backend. `actix-session` provides some built-in storage backends: `CookieSessionStore`, `RedisSessionStore`, and `RedisActorSessionStore`. 

But you can create a custom storage backend by implementing the `SessionStore` trait if required. 


[[sec-actix-components]]
=== Understanding Actix Session Components

==== The Three Main Components

. *SessionMiddleware - The Traffic Controller*  
This is like a traffic controller that sits between your application and incoming requests. Every time a user makes a request, the SessionMiddleware:
.. Checks if they have a valid session cookie
.. Handles all the cookie creation, reading, and updating automatically
.. Tells the storage system when to save, load, or delete session data

. *SessionStore - The Storage Interface*  
Think of this as a standardized filing cabinet system. No matter where you actually store your session data, the SessionStore provides the same simple interface to:
.. Save new session information
.. Retrieve existing session data
.. Update session details
.. Delete expired or invalid sessions

. *Storage Backends - Where Data Actually Lives*  
`actix-session` comes with three ready-to-use storage options:
.. `*CookieSessionStore*`: Stores session data directly in the browser cookie (good for small amounts of data)  
.. `*RedisSessionStore*`: Stores session data in a Redis database (recommended for production)  
.. `*RedisActorSessionStore*`: Similar to Redis but uses Actix actors for better performance  

NOTE: *Custom Storage*: You can create your own storage solution by implementing the `SessionStore` trait.

==== How They Work Together
. User makes a request → `SessionMiddleware` intercepts it  
. `SessionMiddleware` asks `SessionStore` to find the user's `Session` data  
. `SessionStore` retrieves data from the chosen storage backend  
. Your application processes the request with `Session` information available  
. Any `Session` changes get saved back through the same chain  



[[sec-actix-identity]]
=== Extending Sessions with actix-identity

While `actix-session` handles raw session state, the `actix-identity` crate adds a higher-level abstraction for *user authentication*.  

- It builds on top of `actix-session` to store a user identity (e.g., a username or user ID).  
- Instead of manually writing and reading from the session, you use the `Identity` extractor:  

[source,rust]
----
Identity::login(&req.extensions(), "user123".to_owned());

if let Some(id) = Identity::identity(&req.extensions()) {
    println!("Logged in as: {}", id);
}
----

This makes login/logout flows much simpler and avoids boilerplate session handling.  


[[sec-actix-cookies]]
=== Low-Level Control with actix-cookies

Both `actix-session` and `actix-identity` rely on cookies under the hood. The `actix-cookies` crate is the **low-level building block** for cookie handling in Actix.  

It provides:
- A `Cookie` type to create and parse cookies
- Middleware to read cookies from incoming requests
- Helpers to set secure cookies in responses  

For example, you can directly manipulate cookies if you need full control outside the session system:  

[source,rust]
----
HttpResponse::Ok()
    .cookie(Cookie::new("custom_token", "abc123"))
    .finish()
----

This is particularly useful when you want to set extra cookies alongside session management, or for implementing custom authentication schemes.  


=== Takeaways

- `actix-cookies`: Low-level cookie utilities (read/write cookies).  
- `actix-session`: Middleware for managing user session state.  
- `actix-identity`: High-level identity and login/logout abstraction built on top of sessions.  

Together, these crates form a flexible stack for authentication in Actix Web applications.


[[sec-pratical-examples]]
== Pratical Examples in Rust

[[sec-minimal-example]]
=== Simple Session-Based Authentication 

This is a didactial example that demonstrates the core idea of session-based authentication without relying on Actix Web helper middlewares, such as actix-sessions, actix-identity or actix-cookies. 

We intentionally keep it simple and build everything manually to show how session authentication works at the HTTP level:

- We use a fake user database (i.e., a HashMap) to store `usernames` and `passwords`.
- We use a simple server-side session store (i.e., a HashMap<session_id, username>) to store current session IDs.
- We use a random ID generator to create session IDs. 
- We manually set Cookie headers to send back to users.

In this way, we try to show that sessions are basically a server-side lookup table and a cookie with a session ID on the client.

*Example code*

Check the first example in: link:examples/minimal_session_based_auth.rs[examples/minimal_session_based_auth.rs]

*Run the example with*

[source, bash]
----
cargo run --example minimal-session-auth-example
---- 


*Test with curl*

- Login (POST JSON):
+
.login alice
[source, bash]
----
curl -v -X POST http://127.0.0.1:8080/login \
        -H "Content-Type: application/json" \
        -d '{"username":"alice", "password":"password123"}' \
        -c cookie_alice.txt
----
+
.login bob
[source, bash]
----
curl -v -X POST http://127.0.0.1:8080/login \
        -H "Content-Type: application/json" \ 
        -d '{"username":"bob","password":"password321"}'\
        -c cookie_bob.txt \
----
+
NOTE: *`-c cookies.txt`* → Stores overwrite or append any cookies received from the server into cookies.txt
+
- Check user status (GET):
+
.status alice
[source, bash]
----
 curl -v  http://127.0.0.1:8080/status -b cookie_alice.txt
----
+
.status bob
[source, bash]
----
 curl -v  http://127.0.0.1:8080/status -b cookie_bob.txt
----
+
NOTE: *`-b cookies.txt`* → Reads cookies from the file cookies.txt and includes them in the request
+
- Logout:
+
.logout alice
[source, bash]
----
curl -v -X POST http://127.0.0.1:8080/logout -b cookie_alice.txt -c cookie_alice.txt
----
+
.logout bob
[source, bash]
----
curl -v -X POST http://127.0.0.1:8080/logout -b cookie_bob.txt -c cookie_bob.txt
----

NOTE: At each test, we can check the cookie being upated in the cookie file: `cookie_<alice||bob>.txt`.


=== Session-Based Authentication with Actix-Web Middlewares

In the previous example we built a minimal session-based authentication system from scratch.
We manually generated session IDs, manually inserted cookies (Set-Cookie headers), manually parsed cookies from requests, etc.

That is a good first step for learning the fundamentals, but in real applications you don't need to implement all of that yourself. Why not? In real applications: 

- Cookies should be signed and encrypted to prevent tampering. 
- Passwords must be encrypted, we never store plain-text passwords.
- Sessions should support expiration and rotation.
- Identity should be easy to store and retrieve.
- Ideally, prevent brute-force attacks by limiting login attempts, temporarily locking accounts after multiple failures, and  logging and monitoring of login attempts.

This is where Actix middlewares come in.
As we presented in the section <<sec-actix-middlewares>>, 
Actix Web handles the tedious details of the authentication process while we can focus on the application business logic.

NOTE: Remember, a Middleware is registered for each App, Scope, or Resource and executed in opposite order as registration.

The next didactic example demonstrates how to implement session-based authentication in Actix Web using the built-in helper middlewares: actix-session and actix-identity.
Instead of manually setting and parsing cookies, we let the middlewares handle the heavy lifting:

- SessionMiddleware takes care of securely serializing session data into cookies (signing/encrypting them with a secret key).
- IdentityMiddleware builds on top of sessions and provides a simple API (login, logout, identity) to manage the current user’s identity.
- We still use a fake user database (a HashMap) for demonstration purposes.
- On login, we validate the credentials and call Identity::login to store the user in the session.
- On subsequent requests, the identity can be retrieved with Identity::identity.
- On logout, we call logout to remove the identity from the session.

In this way, we show that authentication becomes much simpler when relying on Actix’s session and identity middlewares, we don't deal with raw cookies, just high-level APIs.

*Example code*

Check the example in: link:examples/actix_web_sessoin_based_auth.rs[examples/actix_web_sessoin_based_auth.rs]



*Run the example with*

[source, bash]
----
cargo run --example actix-session-auth-example
---- 

