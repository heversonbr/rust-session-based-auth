:toc: left
:toclevels: 3
:source-highlighter: rouge
:linenums:

= Session-based Authentication in Rust

[[sec-intro]]
== Introduction 

Session-based authentication provides a secure and efficient alternative to Basic authentication schemes.
Unlike Basic authentication, where credentials are sent with every request, session-based authentication validates user credentials once and then uses session tokens for subsequent  requests.

[[sec-advantages]]
== Key Advantages

* *Reduced network exposure*: Credentials (username and password) are transmitted only during the initial login, minimizing the risk of interception
* *Improved performance*: Server validates credentials once during login; subsequent requests only require session ID validation
* *Enhanced security*: Session IDs stored in cookies replace repeated credential transmission
* *Stateful management*: Server maintains session state and securely hashed credentials, enabling easier session invalidation and logout
* *Extra flexibility*: Sessions can store additional metadata (e.g., roles, permissions, expiration time, etc), allowing:
role-based access control, permission management, configurable session expiration, prevention of session hijacking and other security threats.

[[sec-flows]]
== Authentication flows

The flow of session-based authentication process can be described according its distinct phases:

[[sec-signup]]
=== User Registration (Sign-up) 

. User submits username + password over HTTPS (https only).
. Server generates a random salt (e.g. 16–32 bytes).
. Server hashes the password with a password hashing algorithm (bcrypt, Argon2, or scrypt), e.g., `hashed_password = bcrypt(password + salt)`
. Server stores in DB: username,  hashed_password, salt (not secret, stored alongside the hash) and optional metadata (e.g. password version, created_at).

NOTE: Storing only hashes prevents leaks from exposing real passwords.
 
[[sec-login]]
=== User Login (Sign-in) 

. User submits username + password (over HTTPS).
. Server looks up the stored record for that username.
. Server retrieves salt and hashed_password.
. Server recomputes bcrypt(submitted_password + salt).
. If `computed hash == stored hash` → authentication succeeds.

NOTE: Password is never stored or logged, only verified securely.

[[sec-session-creation]]
=== Session Creation

If successful authentication: 

. Server generates a session ID (random, cryptographically strong).
. Server stores session info in memory or DB (Redis, SQL, etc.).
. Server sends the session ID back to the client in a cookie with `Set-Cookie`, remember these options:
.. *HttpOnly*:  The cookie cannot be accessed by JavaScript, protects against XSS (Cross-Site Scripting) attacks.
.. *Secure*: The cookie is only sent over HTTPS, never over plain HTTP, prevents session hijacking via network sniffing.
.. *SameSite*=Strict or *SameSite*=Lax: Controls when cookies are sent in cross-site requests, prevents CSRF (Cross-Site Request Forgery) attacks. 

.example 1: A session stored in memory or DB on the server could look like this
[example]
----
{
  "session_id": "abc123xyz",
  "user_id": "42",
  "expires_at": "2025-09-24T12:00:00Z",
  "ip": "optional",
  "user_agent": "optional"
}
----


.example 2: A Server's response to a login request, providing session information
[example]
----
HTTP/1.1 200 OK
Set-Cookie: session_id=abc123xyz; HttpOnly; Secure;SameSite=Lax; Path=/; Max-Age=1800
Content-Type: application/json
----


[[sec-subsequent-requests]]
===  Subsequent Requests

. Client includes the session cookie automatically.
. Server (middleware) looks up the session ID in the sessionn store (memory or DB), verifies its validity,  attaches user identity to the request (e.g., this request comes from username: "alice", id: 42) before forwarding it to the request handler. 


.example 3: One client's subsequent request should look like this
[example]
----
GET /dashboard HTTP/1.1
Host: example.com
Cookie: session_id=abc123xyz
----

.example 4: Session middleware finds out session information from the Session Store
[example]
----
{
  "session_id": "abc123xyz",
  "user_id": 42,
  "username": "alice",
  "roles": ["admin"],
  "expires_at": "2025-09-24T12:00:00Z"
}
----

NOTE: Password never need to be re-sent, it only proves identity using the session ID.

[[sec-expiration]]
=== Session Expiration and Renewal

. Sessions should expire after a reasonable time (e.g. 15-30 min inactivity, max 1-7 days).
. On logout
.. Server deletes session from server's Session Store.
.. Server clears client's cookie:  server responds with `Set-Cookie: session_id=; Max-Age=0`
. Any future request without a valid cookie is treated as user is `logged out`.


[[sec-actix-middlewares]]
== Session-based Authentication with Rust and Actix Web Middlewares

The `actix-session` is a complete toolkit for handling user sessions in your Actix Web application. It's designed to make session management simple and flexible.
The `SessionMiddleware` is the middleware providing the `actix-session` functionalities. 

It takes care of all the session cookie handling and instructs the storage backend to create/delete/update the session state based on the operations performed against the active session. Sessions are backed by a `SessionStore`. 

The `SessionStore` is the interface used to retrieve and save the current session data from/to the chosen storage backend. `actix-session` provides some built-in storage backends: `CookieSessionStore`, `RedisSessionStore`, and `RedisActorSessionStore`. 

But you can create a custom storage backend by implementing the `SessionStore` trait if required. 


[[sec-actix-components]]
=== Understanding Actix Session Components

==== The Three Main Components

. *SessionMiddleware - The Traffic Controller*  
This is like a traffic controller that sits between your application and incoming requests. Every time a user makes a request, the SessionMiddleware:
.. Checks if they have a valid session cookie
.. Handles all the cookie creation, reading, and updating automatically
.. Tells the storage system when to save, load, or delete session data

. *SessionStore - The Storage Interface*  
Think of this as a standardized filing cabinet system. No matter where you actually store your session data, the SessionStore provides the same simple interface to:
.. Save new session information
.. Retrieve existing session data
.. Update session details
.. Delete expired or invalid sessions

. *Storage Backends - Where Data Actually Lives*  
`actix-session` comes with three ready-to-use storage options:
.. `*CookieSessionStore*`: Stores session data directly in the browser cookie (good for small amounts of data)  
.. `*RedisSessionStore*`: Stores session data in a Redis database (recommended for production)  
.. `*RedisActorSessionStore*`: Similar to Redis but uses Actix actors for better performance  

NOTE: *Custom Storage*: You can create your own storage solution by implementing the `SessionStore` trait.

==== How They Work Together
. User makes a request → `SessionMiddleware` intercepts it  
. `SessionMiddleware` asks `SessionStore` to find the user's `Session` data  
. `SessionStore` retrieves data from the chosen storage backend  
. Your application processes the request with `Session` information available  
. Any `Session` changes get saved back through the same chain  



[[sec-actix-identity]]
=== Extending Sessions with actix-identity

While `actix-session` handles raw session state, the `actix-identity` crate adds a higher-level abstraction for *user authentication*.  

- It builds on top of `actix-session` to store a user identity (e.g., a username or user ID).  
- Instead of manually writing and reading from the session, you use the `Identity` extractor:  

[source,rust]
----
Identity::login(&req.extensions(), "user123".to_owned());

if let Some(id) = Identity::identity(&req.extensions()) {
    println!("Logged in as: {}", id);
}
----

This makes login/logout flows much simpler and avoids boilerplate session handling.  


[[sec-actix-cookies]]
=== Low-Level Control with actix-cookies

Both `actix-session` and `actix-identity` rely on cookies under the hood. The `actix-cookies` crate is the **low-level building block** for cookie handling in Actix.  

It provides:
- A `Cookie` type to create and parse cookies
- Middleware to read cookies from incoming requests
- Helpers to set secure cookies in responses  

For example, you can directly manipulate cookies if you need full control outside the session system:  

[source,rust]
----
HttpResponse::Ok()
    .cookie(Cookie::new("custom_token", "abc123"))
    .finish()
----

This is particularly useful when you want to set extra cookies alongside session management, or for implementing custom authentication schemes.  


=== Takeaways

- `actix-cookies`: Low-level cookie utilities (read/write cookies).  
- `actix-session`: Middleware for managing user session state.  
- `actix-identity`: High-level identity and login/logout abstraction built on top of sessions.  

Together, these crates form a flexible stack for authentication in Actix Web applications.


[[sec-pratical-examples]]
== Pratical Examples in Rust

[[sec-minimal-example]]
=== Simple Session-Based Authentication 

This is a didactial example that demonstrates the core idea of session-based authentication without relying on Actix Web helper middlewares, such as actix-sessions, actix-identity or actix-cookies. 

We intentionally keep it simple and build everything manually to show how session authentication works at the HTTP level:

- We use a fake user database (i.e., a HashMap) to store `usernames` and `passwords`.
- We use a simple server-side session store (i.e., a HashMap<session_id, username>) to store current session IDs.
- We use a random ID generator to create session IDs. 
- We manually set Cookie headers to send back to users.

In this way, we try to show that sessions are basically a server-side lookup table and a cookie with a session ID on the client.

*Example code*

Check the first example in: link:examples/minimal_session_based_auth.rs[examples/minimal_session_based_auth.rs]

*Run the example with*

[source, bash]
----
cargo run --example minimal-session-auth-example
---- 


*Test with curl*

- Login (POST JSON):
+
.login alice
[source, bash]
----
curl -v -X POST http://127.0.0.1:8080/login \
        -H "Content-Type: application/json" \
        -d '{"username":"alice", "password":"password123"}' \
        -c cookie_alice.txt
----
+
.login bob
[source, bash]
----
curl -v -X POST http://127.0.0.1:8080/login \
        -H "Content-Type: application/json" \ 
        -d '{"username":"bob","password":"password321"}'\
        -c cookie_bob.txt \
----
+
NOTE: *`-c cookies.txt`* → Stores overwrite or append any cookies received from the server into cookies.txt
+
- Check user status (GET):
+
.status alice
[source, bash]
----
 curl -v  http://127.0.0.1:8080/status -b cookie_alice.txt
----
+
.status bob
[source, bash]
----
 curl -v  http://127.0.0.1:8080/status -b cookie_bob.txt
----
+
NOTE: *`-b cookies.txt`* → Reads cookies from the file cookies.txt and includes them in the request
+
- Logout:
+
.logout alice
[source, bash]
----
curl -v -X POST http://127.0.0.1:8080/logout -b cookie_alice.txt -c cookie_alice.txt
----
+
.logout bob
[source, bash]
----
curl -v -X POST http://127.0.0.1:8080/logout -b cookie_bob.txt -c cookie_bob.txt
----

NOTE: At each test, we can check the cookie being upated in the cookie file: `cookie_<alice||bob>.txt`.


[[sec-auth-with-middleware]]
=== Session-Based Authentication with Actix-Web Middlewares

In the previous example we built a minimal session-based authentication system from scratch.
We manually generated session IDs, manually inserted cookies (Set-Cookie headers), manually parsed cookies from requests, etc.

That is a good first step for learning the fundamentals, but in real applications you don't need to implement all of that yourself. Why not? In real applications: 

- Cookies should be signed and encrypted to prevent tampering. 
- Passwords must be encrypted, we never store plain-text passwords.
- Sessions should support expiration and rotation.
- Identity should be easy to store and retrieve.
- Ideally, prevent brute-force attacks by limiting login attempts, temporarily locking accounts after multiple failures, and  logging and monitoring of login attempts.

This is where Actix middlewares come in.
As we presented in the section <<sec-actix-middlewares>>, 
Actix Web middlewares handle the tedious details of the authentication process while we can focus on the application business logic.

NOTE: Remember, a Middleware is registered for each App, Scope, or Resource and executed in opposite order as registration.

[[sec-outofthebox-middleware]]
==== Out-of-the-box Authentication Middlewares

Actix-web provides several useful middleware out of the box.
The next example didactically demonstrates how to implement session-based authentication in Actix Web using some of these provided built-in helper middlewares: 

- *actix-session*, and 
- *actix-identity*

Instead of manually setting and parsing cookies, we let the middlewares handle some heavy lifting (e.g.,validation, DB lookups).

- *SessionMiddleware* takes care of securely serializing session data into cookies (signing/encrypting them with a secret key).
- *IdentityMiddleware* builds on top of sessions and provides a simple API (login, logout, identity) to manage the current user's identity.
- We still use a fake user database (a HashMap) for demonstration purposes.
- On login, we validate the credentials and call Identity::login to store the user in the session.
- On subsequent requests, the identity can be retrieved with Identity::identity.
- On logout, we call logout to remove the identity from the session.

In this way, we show that authentication becomes much simpler when relying on Actix's session and identity middlewares, we do not deal with raw cookies, just high-level APIs.

*Example code*

Check the example in: link:examples/actix_web_session_based_auth_with_middleware.rs[examples/actix_web_session_based_auth_with_middleware.rs]

*Run the example with*

[source, bash]
----
cargo run --example actix-session-auth-example
---- 

==== Improved use of Authentication Middlewares with Extractors

While we can enforce security with just middleware, some drawbacks will exist concerning the code clarity, maintainability, and handler _purity_ (i.e., clean handler signatures). 

Remind, handlers handle logic: The primary job of your route handlers (e.g., login, status, logout) is to execute the business logic (e.g., retrieving profile data, processing a payment). They should not be concerned with how a user was authenticated.

For instance, in the previous example link:examples/actix_web_sessoin_based_auth_with_middleware.rs[session based authentication with middlewares], although we use *SessionMiddleware* and *IdentityMiddleware* for intercepting requests, reading cookies, validating sessions and identities we still need to perform authentication operations in the handler before performing its own logic. 
Check the `status` route: 

[source, rust, linenums]
----
async fn status(identity: Option<Identity>) -> impl Responder {
    match identity {
        Some(user) => match user.id() {
            Ok(user_id) => {
                ...  // [ Handler logic ] 
            }
            Err(err) => {
                error!("Failed to read ID from session: {}", err);
                ...
            }
        },
        None => {
            error!("No identity found in Request");
            ...
        }
    }
}
----

This will definitely create high verbosity and duplications.
If you have 50 protected routes, you duplicate the authentication check 50 times. That is, every protected handler must contain a bulky block such as:

[source, rust, linenums]
----
match identity {
  Some(user) => match user.id() {
      Ok(user_id) => { [Handles logic] }
      Err(err) => { error!("Failed to read ID from session: {}", err);... }
  },
  None => { error!("No identity found in Request"); ... }
}
----

Any change to the authentication logic will require 50 updates to fix each protected route.

*Extractors*

The primary goal of the Extractor pattern is to separate the security concern from the business logic.
Extractors (e.g., AuthUser, AdminUser) are the Route Guards that leverage the work done by the middleware. They implement the Actix-web FromRequest trait, allowing them to intercept the request flow right before the handler is called.

. *Centralized Enforcement*:  
.. *Improvement*: The Extractor's primary role is to enforce a precondition for the handler.
.. *Mechanism*: The AuthUser extractor checks the request extensions for the identity placed there by the IdentityMiddleware.
... If the identity is present, the extractor succeeds, and the request continues.
... If the identity is absent, the extractor immediately fails by returning an error (e.g., ErrorUnauthorized), and Actix-web automatically short-circuits the request and sends the `401 response`.
.. *Design Benefit*: This centralizes the security policy. The application guarantees that if a handler takes an AuthUser, the user must be logged in. No handler can forget the check.
. *Cleaner Handler Signatures* (The "Purity" Role):
.. *Improvement*: Extractors dramatically reduce code verbosity and duplication.
.. *Mechanism*: Instead of every protected handler needing boilerplate, the handler becomes perfectly clean.
. *Role-Based Access Control* (The "Authorization" Role)

.. *Improvement*: Extractors allow for easy implementation of Authorization (checking what an authenticated user is allowed to do).
.. *Mechanism*: The `AdminUser` extractor builds on `AuthUser`. It not only checks for a login but also queries the application state (`AppState`) to verify the user's role. If the role check fails, it returns a `403 Forbidden` error.
.. *Design Benefit*: This establishes a clean `Authorization Guard` pattern, making it trivial to secure routes based on user privileges without polluting the handler logic.

The next example centralizes the security logic using two extractors: a custom `Extractor` (for authentication) and an Identity `Extractor Guard` (for role-based access control), which is a powerful and clean design pattern for scalable applications. These two structs implement `actix_web::FromRequest` to enforce security rules before the handler runs.

We use `SessionMiddleware` + `IdentityMiddleware` (Middleware) to handle cookies and prepare the identity object.
And we use `AuthUser` / `AdminUser` (Extractors) as the route guard to enforce security and provide clean user data to the handler.

- The Authentication Extractor (`AuthUser`): Ensures a user is logged in (`HTTP 401` Unauthorized if no identity is present.).
-The Role-Based Guard Extractor (`AdminUser`): Builds on top of `AuthUser` and enforces a specific role (It fails with `HTTP 403 Forbidden` if the user is authenticated but lacks the necessary role).
- `App State` for Roles: Simulates database user roles for checking permissions.
- We modify the `AppState` to include roles and create the new Extractors.

*Example code* 

Check the example in: link:examples/actix_web_session_based_auth_advanced_middlware.rs[examples/actix_web_session_based_auth_advanced_middlware.rs]


.Routes used in this example 
[cols="1,1,1,1,1,2", options="header"]
|===
| Action | Route | Required Extractor | Result | HTTP Code | Notes

| Anonymous | /profile | AuthUser | Extraction fails | 401 Unauthorized | Fails because no session/identity exists.
| Login | /login | None | Success | 200 OK | Creates the session/identity cookie.
| Alice | /profile | AuthUser | Success | 200 OK | Authenticated and granted access.
| Alice | /admin | AdminUser | Extraction fails | 403 Forbidden | Authenticated, but fails the role check.
| Bob | /admin | AdminUser | Success | 200 OK | Authenticated and passes the role check.
|===



*Test with curl*


.check public route
[source, bash]
----
curl -v http://127.0.0.1:8080/   

# access public route
# Returns: 200 OK -> Welcome to the public homepage. 
----


.Try to access a profile without logging in (Anonymous)
[source, bash]
----
curl -v http://127.0.0.1:8080/profile   
 
# Fails because no session/identity exists.
# Returns: 401 Unauthorized -> Login Required
----


.login Alice
[source, bash]
----
curl -v POST http://127.0.0.1:8080/login \
     -H "Content-Type: application/json" \
     -d '{"username":"alice", "password":"password123"}' \
     -c cookie_alice.txt

# Creates the session/identity cookie. 
# -c: stores returned cookie in cookie_alice.txt
# Returns: 200 OK
# {
#   "authenticated":true,
#   "user_id":"alice",
#   "role":"User",
#   "message":"Login successful"
# }
----

.checks Alice's authentication and granted access
[source, bash]
----
curl -v http://127.0.0.1:8080/profile -b cookie_alice.txt

# Authenticated and granted access to alice's private profile
# Returns: 200 OK
# {
#   "authenticated":true,
#   "user_id":"alice",
#   "role":"User",
#   "message":"Welcome to your profile area!"
# }
----

.verify authorization: Alice tries to access an ungranted route
[source, bash]
----
curl -v http://127.0.0.1:8080/admin -b cookie_alice.txt

# Authenticated, but fails the role check (alice's role is not admin).
# Returns: 403 Forbidden -> Admin Access Required
----

.login bob
[source, bash]
----
curl -v POST http://127.0.0.1:8080/login \
     -H "Content-Type: application/json" \
     -d '{"username":"bob", "password":"password321"}'\
     -c cookie_bob.txt

# Creates the session/identity cookie. 
# -c: stores returned cookie in cookie_bob.txt
# Returns: 200 OK
# {
#   "authenticated":true,
#   "user_id":"bob",
#   "role":"Admin",
#   "message":"Login successful"
# }

----

.checks Bob's authentication and granted access
[source, bash]
----
curl -v http://127.0.0.1:8080/profile -b cookie_bob.txt

# Authenticated and granted access to Bob's private profile
# Returns: 200 OK
# {
#   "authenticated":true,
#   "user_id":"bob",
#   "role":"Admin",
#   "message":"Welcome to your profile area!"
# }

----

.verify authorization: Bob tries to access an proteced 'admin-only' route
[source, bash]
----
curl -v http://127.0.0.1:8080/admin -b cookie_bob.txt

# Returns: 200 OK 
# {
#   "authenticated":true,
#   "user_id":"bob",
#   "role":"Admin",
#   "message":"Welcome to the restricted Admin Dashboard!"
# }
# Authenticated, and granted access to 'admin' protected area.
----

.logout Alice
[source, bash]
----
curl -v -X POST http://127.0.0.1:8080/logout -b cookie_alice.txt -c cookie_alice.txt

# User alice logs out successfully.
# Returns: 200 OK
# {
#   "authenticated":false,
#   "user_id":"alice",
#   "role":"",
#   "message":"User alice logged out."
# }
----

.logout Bob
[source, bash]
----
curl -v -X POST http://127.0.0.1:8080/logout -b cookie_bob.txt -c cookie_bob.txt

# User bob logs out successfully
# Returns:  200 OK
# { 
#   "authenticated":false,
#   "user_id":"bob",
#   "role":"",
#   "message":"User bob logged out."
# }
----

NOTE: *`-b cookies.txt`* → Reads cookies from the file cookies.txt and includes them in the request. At each test, we can check the cookie being upated in the cookie files: `cookie_<alice||bob>.txt`.


*Design Benefits*: 

- This centralizes the security policy. The application guarantees that if a handler takes an `AuthUser`, the user must be logged in. No handler can forget the check.

- Handlers become pure business logic, increasing maintainability and testability.

- Establishes a clean Authorization Guard pattern, making it trivial to secure routes based on user privileges without polluting the handler logic.

In summary, the `Middleware` sets the stage by handling the session mechanics, while the `Extractor` steps in as the gatekeeper to enforce the security policy defined for each specific route.